#!/usr/bin/env python3
#-*-encoding:utf-8*-

import os
import sys
import time
import json
import crypt
from multiprocessing import Pool

TEST_PASS="password"
TEST_SALT='$y$j9T$F31F/jItUvvjOv6IBFNea/$'
assert crypt.crypt(TEST_PASS, TEST_SALT) == "$y$j9T$F31F/jItUvvjOv6IBFNea/$pCTLzX1nL7rq52IXxWmYiJwii4RJAGDJwZl/LHgM/UD"

HASH_DELIMITER = " - "

def statusline(line):
    sys.stdout.write(f"\033[2K\r{line}")
    sys.stdout.flush()

def detect_hash_functions(hashes):
    res = []
    for h in hashes:
        if h == "":
            continue
        hashparts = h.lstrip(" ").split(" - ")
        if len(hashparts) < 3:
            raise Exception("Wrong hash format")
        brute_type = hashparts[0]
        hashres = { "id": hashparts[1], "type": brute_type }

        if brute_type == "cryptpass":
            hashres["data"] = {
                "salt": "$".join(hashparts[2].split("$")[:-1]) + "$",
                "result": hashparts[2].split("$")[-1].rstrip(),
            }
        else:
            raise Exception(f"Bruteforce type \"{brute_type}\" not yet implemented")
        res.append(hashres)
    return res

def try_word(args):
    word, hash = args
    if hash["type"] == "cryptpass":
        res = crypt.crypt(word, hash["data"]["salt"])
        if res.split("$")[-1] == hash["data"]["result"]:
            return {
                "id": hash["id"],
                "plain": word,
            }
    return None

def bruteforce(wordlist, hashes, nproc, statef, state_modulo=100):
    state = { "nwords": 0, "found": {} }
    if statef and os.path.isfile(statef):
        with open(statef, "r") as f:
            state.update(json.load(f))
    words = []
    ntot_tries = 0
    tstart = time.time()
    with Pool(nproc) as pool:
        for nw, word in enumerate(wordlist.readlines()):
            if nw < state["nwords"]:
                continue

            if nw % state_modulo == 0:
                tps = ntot_tries / (time.time() - tstart)
                statusline("{} words of the wordlist tried, {} hashes left ({} tries / sec)".format(nw, len(hashes), tps))
                if statef:
                    with open(statef, "w") as f:
                        json.dump(state, f, indent=2)

            try:
                words.append(word.decode().strip())
            except UnicodeDecodeError:
                continue
            if len(words) >= nproc:
                tries = list()
                for w in words:
                    ntot_tries += 1
                    for h in hashes:
                        tries.append((w, h))
                for result in pool.map(try_word, tries):
                    if result:
                        state["found"][result["id"]] = result["plain"]
                        hashes = [h for h in hashes if h["id"] != result["id"]]
                words = []
            if len(hashes) == 0:
              break;
            state["nw"] = nw

    if len(words) > 0:
        for word in words:
            ntot_tries += 1
            for hash in hashes:
                result = try_word((word, hash))
                if result:
                    state["found"][result["id"]] = result["plain"]
                    hashes = [h for h in hashes if h["id"] != result["id"]]
    print("Took", time.time() - tstart, "seconds to try", ntot_tries, "words")
    print("")
    return state["found"]

args = sys.argv[1:]
if len(args) < 3:
    print("Usage: {} <hash file> <wordlist file> <nproc> <statefile>".format(sys.argv[0]))
    sys.exit(1)

hashf = args[0]
wlf = args[1]
nproc = int(args[2])
if len(args) == 4:
    statefile = args[3]
else:
    statefile = None
wl = open(wlf, "rb")

with open(hashf, "r") as f:
    hashes = f.read().split("\n")

try:
    hashes = detect_hash_functions(hashes)
    result = bruteforce(wl, hashes, nproc, statefile)
    for id, res in result.items():
        print(f"Found \"{id}\": \"{res}\"")
    for hash in hashes:
        if hash["id"] in result.keys():
            continue
        print("Not found {}".format(hash["id"]))

finally:
    wl.close()
